CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW orders_with_delivery AS select o.id AS id,o.created_at AS created_at,o.customer_name AS customer_name,o.email AS customer_email,o.phone AS customer_phone,o.total AS total,o.payment_status AS payment_status,o.delivery_address AS delivery_address,o.delivery_city AS delivery_city,o.delivery_contact_name AS delivery_contact_name,o.delivery_contact_phone AS delivery_contact_phone,o.delivery_date AS delivery_date,count(distinct dg.id) AS delivery_groups,count(dgi.id) AS total_items from ((orders o left join delivery_groups dg on((dg.order_id = o.id))) left join delivery_group_items dgi on((dgi.delivery_group_id = dg.id))) group by o.id order by o.created_at desc;

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW product_availability AS select p.id AS product_id,p.name AS product_name,p.store_id AS store_id,s.name AS store_name,pdc.capacity_date AS capacity_date,(pdc.available_capacity - pdc.booked_capacity) AS available_slots,p.stock_quantity AS current_stock,least(p.stock_quantity,(pdc.available_capacity - pdc.booked_capacity)) AS total_available from ((products p join stores s on((s.id = p.store_id))) join product_daily_capacity pdc on((pdc.product_id = p.id))) where ((p.active = 1) and (pdc.capacity_date >= curdate())) order by pdc.capacity_date;

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW products_low_stock AS select p.id AS id,p.name AS name,p.store_id AS store_id,s.name AS store_name,p.stock_quantity AS stock_quantity,p.stock_min_threshold AS stock_min_threshold,(case when (p.stock_quantity <= p.stock_min_threshold) then 'LOW' else 'OK' end) AS stock_status from (products p join stores s on((s.id = p.store_id))) where (p.stock_quantity <= p.stock_min_threshold) order by p.stock_quantity;

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW store_config_summary AS select s.id AS store_id,s.name AS store_name,count(sc.id) AS total_configs,count((case when (sc.category = 'payment_methods') then 1 end)) AS payment_configs,count((case when (sc.category = 'language') then 1 end)) AS language_configs,count((case when (sc.category = 'permissions') then 1 end)) AS permission_configs,count((case when (sc.category = 'integrations') then 1 end)) AS integration_configs,count((case when (sc.category = 'notifications') then 1 end)) AS notification_configs,count((case when (sc.category = 'general') then 1 end)) AS general_configs,max(sc.updated_at) AS last_updated from (stores s left join store_configurations sc on((s.id = sc.store_id))) group by s.id,s.name;

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW user_addresses_view AS select a.id AS id,a.user_id AS user_id,u.email AS email,a.type AS type,a.label AS label,a.street_address AS street_address,a.city AS city,a.state_province AS state_province,a.postal_code AS postal_code,a.country AS country,a.is_default AS is_default from (addresses a join users u on((a.user_id = u.id)));

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW user_roles_view AS select u.id AS user_id,u.email AS email,u.status AS status,u.created_at AS created_at,up.first_name AS first_name,up.last_name AS last_name,ur.role AS role,ur.store_id AS store_id,ur.granted_at AS granted_at from ((users u left join user_profiles up on((u.id = up.user_id))) left join user_roles ur on((u.id = ur.user_id)));

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW v_appointment_daily_stats AS select a.store_id AS store_id,cast(a.appointment_date as date) AS appointment_date,count(0) AS total_appointments,count((case when (a.status = 'completada') then 1 end)) AS completed_count,count((case when (a.status = 'cancelada') then 1 end)) AS cancelled_count,count((case when (a.status = 'no_asistio') then 1 end)) AS no_show_count,avg(a.duration_hours) AS avg_duration_hours,count((case when (s.is_recurring = 1) then 1 end)) AS recurring_appointments from (store_appointments a left join store_services s on((a.service_id = s.id))) group by a.store_id,cast(a.appointment_date as date);

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW v_popular_services AS select s.store_id AS store_id,s.id AS service_id,s.name AS service_name,count(a.id) AS total_appointments,count((case when (a.status = 'completada') then 1 end)) AS completed_appointments,round(((count((case when (a.status = 'completada') then 1 end)) * 100.0) / greatest(count(0),1)),2) AS completion_rate,avg(a.duration_hours) AS avg_actual_duration,s.default_duration_hours AS scheduled_duration from (store_services s left join store_appointments a on((s.id = a.service_id))) where (s.is_active = 1) group by s.id,s.name order by total_appointments desc;

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW v_schedule_utilization AS select sc.store_id AS store_id,cast(ss.date as date) AS schedule_date,ss.start_time AS start_time,ss.end_time AS end_time,count(a.id) AS booked_slots,count((case when (a.status = 'completada') then 1 end)) AS completed_slots,round(((count((case when (a.status = 'completada') then 1 end)) * 100.0) / greatest(count(0),1)),2) AS utilization_percentage from ((store_schedule_config sc left join appointment_time_slots ss on(((sc.store_id = ss.store_id) and (cast(ss.date as date) >= curdate())))) left join store_appointments a on(((sc.store_id = a.store_id) and (cast(a.appointment_date as date) = cast(ss.date as date)) and (cast(a.appointment_date as time) between ss.start_time and ss.end_time)))) group by sc.store_id,cast(ss.date as date),ss.start_time,ss.end_time;

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW view_deliveries_complete AS select d.id AS id,d.store_id AS store_id,d.order_id AS order_id,d.order_number AS order_number,d.delivery_method_id AS delivery_method_id,d.assigned_driver_id AS assigned_driver_id,d.customer_name AS customer_name,d.customer_phone AS customer_phone,d.customer_email AS customer_email,d.delivery_address AS delivery_address,d.delivery_city AS delivery_city,d.delivery_zip_code AS delivery_zip_code,d.delivery_instructions AS delivery_instructions,d.order_total AS order_total,d.delivery_cost AS delivery_cost,d.items_count AS items_count,d.total_weight AS total_weight,d.scheduled_date AS scheduled_date,d.scheduled_time_slot AS scheduled_time_slot,d.estimated_delivery_time AS estimated_delivery_time,d.actual_delivery_time AS actual_delivery_time,d.delivery_duration_minutes AS delivery_duration_minutes,d.status AS status,d.priority AS priority,d.is_fragile AS is_fragile,d.requires_signature AS requires_signature,d.delivery_latitude AS delivery_latitude,d.delivery_longitude AS delivery_longitude,d.driver_current_latitude AS driver_current_latitude,d.driver_current_longitude AS driver_current_longitude,d.last_location_update AS last_location_update,d.tracking_number AS tracking_number,d.notes AS notes,d.delivery_proof_url AS delivery_proof_url,d.recipient_signature_url AS recipient_signature_url,d.failure_reason AS failure_reason,d.return_address AS return_address,d.created_at AS created_at,d.updated_at AS updated_at,dm.name AS method_name,dm.type AS method_type,dm.base_cost AS method_base_cost,dd.name AS driver_name,dd.phone AS driver_phone,dd.vehicle_type AS driver_vehicle_type,dd.vehicle_plate AS driver_vehicle_plate,o.id AS original_order_number,o.total AS original_order_total,(case when (d.status = 'pendiente') then (to_days(d.scheduled_date) - to_days(curdate())) else NULL end) AS days_until_delivery,(case when ((d.scheduled_date < curdate()) and (d.status not in ('entregada','cancelada'))) then 1 else 0 end) AS is_overdue,(case when ((d.actual_delivery_time is not null) and (d.estimated_delivery_time is not null)) then timestampdiff(MINUTE,d.estimated_delivery_time,d.actual_delivery_time) else NULL end) AS delivery_delay_minutes from (((deliveries d left join delivery_methods dm on((d.delivery_method_id = dm.id))) left join delivery_drivers dd on((d.assigned_driver_id = dd.id))) left join orders o on((d.order_id = o.id)));

CREATE ALGORITHM=UNDEFINED DEFINER=root@localhost SQL SECURITY DEFINER VIEW view_driver_performance AS select dd.id AS id,dd.store_id AS store_id,dd.name AS name,dd.phone AS phone,dd.email AS email,dd.license_number AS license_number,dd.license_expiry AS license_expiry,dd.vehicle_type AS vehicle_type,dd.vehicle_make AS vehicle_make,dd.vehicle_model AS vehicle_model,dd.vehicle_year AS vehicle_year,dd.vehicle_plate AS vehicle_plate,dd.vehicle_color AS vehicle_color,dd.max_weight_capacity AS max_weight_capacity,dd.max_volume_capacity AS max_volume_capacity,dd.max_distance_per_day AS max_distance_per_day,dd.active AS active,dd.status AS status,dd.current_latitude AS current_latitude,dd.current_longitude AS current_longitude,dd.last_location_update AS last_location_update,dd.working_hours_start AS working_hours_start,dd.working_hours_end AS working_hours_end,dd.working_days AS working_days,dd.max_deliveries_per_day AS max_deliveries_per_day,dd.delivery_radius_km AS delivery_radius_km,dd.total_deliveries AS total_deliveries,dd.successful_deliveries AS successful_deliveries,dd.failed_deliveries AS failed_deliveries,dd.average_delivery_time AS average_delivery_time,dd.customer_rating AS customer_rating,dd.total_earnings AS total_earnings,dd.can_handle_fragile AS can_handle_fragile,dd.can_handle_cod AS can_handle_cod,dd.preferred_zones AS preferred_zones,dd.excluded_zones AS excluded_zones,dd.notes AS notes,dd.emergency_contact AS emergency_contact,dd.emergency_phone AS emergency_phone,dd.created_at AS created_at,dd.updated_at AS updated_at,(case when (dd.total_deliveries > 0) then round(((dd.successful_deliveries / dd.total_deliveries) * 100),2) else 0 end) AS success_rate_percent,(case when (dd.total_deliveries > 0) then round((dd.failed_deliveries / dd.total_deliveries),2) else 0 end) AS failure_rate_percent,(case when ((dd.successful_deliveries > 0) and (dd.average_delivery_time is not null)) then round(dd.average_delivery_time,2) else NULL end) AS avg_delivery_time_minutes,(case when ((dd.status = 'available') and (dd.working_hours_start <= curtime()) and (dd.working_hours_end >= curtime()) and (find_in_set(dayofweek(curdate()),dd.working_days) > 0)) then 'currently_available' else 'not_available' end) AS real_time_availability from delivery_drivers dd;
